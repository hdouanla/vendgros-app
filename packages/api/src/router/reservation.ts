import { z } from "zod/v4";
import { and, eq } from "drizzle-orm";
import { randomBytes } from "crypto";

import { listing, rating, reservation } from "@acme/db/schema";

import { createTRPCRouter, protectedProcedure } from "../trpc";

// Helper to generate 6-digit alphanumeric code
function generateVerificationCode(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

// Helper to generate QR hash
function generateQRHash(): string {
  return randomBytes(32).toString("hex");
}

export const reservationRouter = createTRPCRouter({
  // Create reservation with 5% deposit
  create: protectedProcedure
    .input(
      z.object({
        listingId: z.string(),
        quantity: z.number().int().positive(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const targetListing = await ctx.db.query.listing.findFirst({
        where: (listings, { eq }) => eq(listings.id, input.listingId),
      });

      if (!targetListing || targetListing.status !== "PUBLISHED") {
        throw new Error("Listing not available");
      }

      if (input.quantity > targetListing.quantityAvailable) {
        throw new Error("Insufficient quantity available");
      }

      if (
        targetListing.maxPerBuyer &&
        input.quantity > targetListing.maxPerBuyer
      ) {
        throw new Error(`Maximum ${targetListing.maxPerBuyer} per buyer`);
      }

      const totalPrice = targetListing.pricePerPiece * input.quantity;
      const depositAmount = totalPrice * 0.05; // 5% deposit

      const qrCodeHash = generateQRHash();
      const verificationCode = generateVerificationCode();

      // Calculate expiry (48 hours from now)
      const expiresAt = new Date(Date.now() + 48 * 60 * 60 * 1000);

      const [newReservation] = await ctx.db
        .insert(reservation)
        .values({
          listingId: input.listingId,
          buyerId: ctx.session.user.id,
          quantityReserved: input.quantity,
          totalPrice,
          depositAmount,
          qrCodeHash,
          verificationCode,
          status: "PENDING",
          expiresAt,
          stripePaymentIntentId: null, // Will be set after Stripe integration
        })
        .returning();

      return {
        reservationId: newReservation.id,
        depositAmount,
        totalPrice,
        verificationCode,
        qrCodeHash,
        // Client secret will be generated by Stripe integration
      };
    }),

  // Confirm payment (update after Stripe payment)
  confirmPayment: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        stripePaymentIntentId: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      if (existingReservation.buyerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Update reservation and decrement listing inventory
      await ctx.db.transaction(async (tx) => {
        // Update reservation status
        await tx
          .update(reservation)
          .set({
            status: "CONFIRMED",
            stripePaymentIntentId: input.stripePaymentIntentId,
          })
          .where(eq(reservation.id, input.reservationId));

        // Decrement listing inventory
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable -
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));
      });

      return { success: true };
    }),

  // Get reservation by ID
  getById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.id),
        with: {
          listing: {
            with: {
              seller: {
                columns: {
                  id: true,
                  email: true,
                  phone: true,
                  ratingAverage: true,
                },
              },
            },
          },
        },
      });

      if (!result) {
        throw new Error("Reservation not found");
      }

      // Only buyer or seller can view
      if (
        result.buyerId !== ctx.session.user.id &&
        result.listing.sellerId !== ctx.session.user.id
      ) {
        throw new Error("Not authorized");
      }

      return result;
    }),

  // Get my reservations (as buyer)
  myReservations: protectedProcedure.query(async ({ ctx }) => {
    const results = await ctx.db.query.reservation.findMany({
      where: (reservations, { eq }) => eq(reservations.buyerId, ctx.session.user.id),
      with: {
        listing: true,
      },
      orderBy: (reservations, { desc }) => [desc(reservations.createdAt)],
    });

    return results;
  }),

  // Verify QR code (seller scans buyer's QR)
  verifyQR: protectedProcedure
    .input(z.object({ qrCodeHash: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(reservations.qrCodeHash, input.qrCodeHash),
        with: {
          listing: {
            columns: {
              sellerId: true,
            },
          },
          buyer: {
            columns: {
              id: true,
              email: true,
              phone: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid QR code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      if (result.status !== "CONFIRMED") {
        throw new Error("Reservation not confirmed");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
      };
    }),

  // Verify manual code (web fallback)
  verifyCode: protectedProcedure
    .input(z.object({ verificationCode: z.string().length(6) }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(
            reservations.verificationCode,
            input.verificationCode.toUpperCase(),
          ),
        with: {
          listing: {
            columns: {
              sellerId: true,
            },
          },
          buyer: {
            columns: {
              email: true,
              phone: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid verification code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
      };
    }),

  // Complete pickup
  completePickup: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        signature: z.string().optional(), // Base64 image for mobile
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can complete
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      const [updated] = await ctx.db
        .update(reservation)
        .set({
          status: "COMPLETED",
          completedAt: new Date(),
        })
        .where(eq(reservation.id, input.reservationId))
        .returning();

      // Rating prompts will be triggered by the frontend
      // Users have 7 days to rate each other after completion
      // Ratings are blind (hidden until both parties submit)

      return updated;
    }),

  // Report no-show
  reportNoShow: protectedProcedure
    .input(z.object({ reservationId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can report
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Check if expired
      if (new Date() < existingReservation.expiresAt) {
        throw new Error("Reservation has not expired yet");
      }

      await ctx.db.transaction(async (tx) => {
        // Mark as no-show
        await tx
          .update(reservation)
          .set({ status: "NO_SHOW", completedAt: new Date() })
          .where(eq(reservation.id, input.reservationId));

        // Return quantity to listing
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable +
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));

        // Auto-assign 1-star rating from seller to buyer for no-show
        await tx.insert(rating).values({
          reservationId: input.reservationId,
          raterId: ctx.session.user.id, // seller
          rateeId: existingReservation.buyerId,
          stars: 1,
          comment: "No-show - buyer did not pick up items within 48 hours",
        });
      });

      return { success: true };
    }),
});
