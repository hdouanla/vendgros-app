import { z } from "zod/v4";
import { and, eq, inArray } from "drizzle-orm";
import { randomBytes } from "crypto";

import { listing, rating, reservation } from "@acme/db/schema";

import { notifyReservationCreated, notifyPickupComplete } from "../lib/notifications";
import { createTRPCRouter, protectedProcedure } from "../trpc";

// Helper to generate 6-digit alphanumeric code
function generateVerificationCode(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

// Helper to generate QR hash
function generateQRHash(): string {
  return randomBytes(32).toString("hex");
}

export const reservationRouter = createTRPCRouter({
  // Create reservation with 5% deposit
  create: protectedProcedure
    .input(
      z.object({
        listingId: z.string(),
        quantity: z.number().int().positive(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const targetListing = await ctx.db.query.listing.findFirst({
        where: (listings, { eq }) => eq(listings.id, input.listingId),
      });

      if (!targetListing || targetListing.status !== "PUBLISHED" || !targetListing.isActive) {
        throw new Error("Listing not available");
      }

      // Prevent sellers from reserving their own listings
      if (targetListing.sellerId === ctx.session.user.id) {
        throw new Error("You cannot reserve your own listing");
      }

      if (input.quantity > targetListing.quantityAvailable) {
        throw new Error("Insufficient quantity available");
      }

      if (
        targetListing.maxPerBuyer &&
        input.quantity > targetListing.maxPerBuyer
      ) {
        throw new Error(`Maximum ${targetListing.maxPerBuyer} per buyer`);
      }

      const totalPrice = targetListing.pricePerPiece * input.quantity;
      const depositAmount = totalPrice * 0.05; // 5% deposit

      const qrCodeHash = generateQRHash();
      const verificationCode = generateVerificationCode();

      // Calculate expiry (48 hours from now)
      const expiresAt = new Date(Date.now() + 48 * 60 * 60 * 1000);

      const [newReservation] = await ctx.db
        .insert(reservation)
        .values({
          listingId: input.listingId,
          buyerId: ctx.session.user.id,
          quantityReserved: input.quantity,
          totalPrice,
          depositAmount,
          qrCodeHash,
          verificationCode,
          status: "PENDING",
          expiresAt,
          stripePaymentIntentId: null, // Will be set after Stripe integration
        })
        .returning();

      // Send notification to buyer
      await notifyReservationCreated({
        buyerEmail: ctx.session.user.email!,
        buyerPhone: undefined,
        listingTitle: targetListing.title,
        depositAmount,
        verificationCode,
        expiresAt,
      }).catch((err) => console.error("Failed to send notification:", err));

      if (!newReservation) {
        throw new Error("Failed to create reservation");
      }

      return {
        reservationId: newReservation.id,
        depositAmount,
        totalPrice,
        verificationCode,
        qrCodeHash,
        // Client secret will be generated by Stripe integration
      };
    }),

  // Confirm payment (update after Stripe payment)
  confirmPayment: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        stripePaymentIntentId: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      if (existingReservation.buyerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Update reservation and decrement listing inventory
      await ctx.db.transaction(async (tx) => {
        // Update reservation status
        await tx
          .update(reservation)
          .set({
            status: "CONFIRMED",
            stripePaymentIntentId: input.stripePaymentIntentId,
          })
          .where(eq(reservation.id, input.reservationId));

        // Decrement listing inventory
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable -
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));
      });

      return { success: true };
    }),

  // Get reservation by ID
  getById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.id),
        with: {
          listing: {
            with: {
              seller: {
                columns: {
                  id: true,
                  email: true,
                  phone: true,
                  ratingAverage: true,
                },
              },
            },
          },
        },
      });

      if (!result) {
        throw new Error("Reservation not found");
      }

      // Only buyer or seller can view
      if (
        result.buyerId !== ctx.session.user.id &&
        result.listing.sellerId !== ctx.session.user.id
      ) {
        throw new Error("Not authorized");
      }

      return result;
    }),

  // Get my reservations (as buyer)
  myReservations: protectedProcedure.query(async ({ ctx }) => {
    const results = await ctx.db.query.reservation.findMany({
      where: (reservations, { eq }) => eq(reservations.buyerId, ctx.session.user.id),
      with: {
        listing: true,
      },
      orderBy: (reservations, { desc }) => [desc(reservations.createdAt)],
    });

    return results;
  }),

  // Get reservations for a specific listing (for sellers to check if listing can be edited)
  getByListingId: protectedProcedure
    .input(z.object({ listingId: z.string() }))
    .query(async ({ ctx, input }) => {
      // First verify the user owns this listing
      const targetListing = await ctx.db.query.listing.findFirst({
        where: (listings, { eq }) => eq(listings.id, input.listingId),
      });

      if (!targetListing) {
        throw new Error("Listing not found");
      }

      if (targetListing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Get all reservations for this listing
      const results = await ctx.db.query.reservation.findMany({
        where: (reservations, { eq }) => eq(reservations.listingId, input.listingId),
        orderBy: (reservations, { desc }) => [desc(reservations.createdAt)],
      });

      return results;
    }),

  // Get pending pickups (as seller) - reservations that have been paid and are awaiting pickup
  getPendingPickups: protectedProcedure.query(async ({ ctx }) => {
    // Get all seller's listings first
    const sellerListings = await ctx.db.query.listing.findMany({
      where: (listings, { eq }) => eq(listings.sellerId, ctx.session.user.id),
      columns: {
        id: true,
      },
    });

    const listingIds = sellerListings.map((l) => l.id);

    if (listingIds.length === 0) {
      return [];
    }

    // Get all reservations for seller's listings that are confirmed (paid deposit)
    const results = await ctx.db.query.reservation.findMany({
      where: (reservations, { and, eq, inArray }) =>
        and(
          inArray(reservations.listingId, listingIds),
          eq(reservations.status, "CONFIRMED"),
        ),
      with: {
        listing: {
          columns: {
            id: true,
            title: true,
            pricePerPiece: true,
            pickupAddress: true,
            pickupInstructions: true,
          },
        },
        buyer: {
          columns: {
            id: true,
            email: true,
            phone: true,
            name: true,
          },
        },
      },
      orderBy: (reservations, { asc }) => [asc(reservations.expiresAt)],
    });

    return results;
  }),

  // Verify QR code (seller scans buyer's QR)
  verifyQR: protectedProcedure
    .input(z.object({ qrCodeHash: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(reservations.qrCodeHash, input.qrCodeHash),
        with: {
          listing: {
            columns: {
              sellerId: true,
            },
          },
          buyer: {
            columns: {
              id: true,
              email: true,
              phone: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid QR code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      if (result.status !== "CONFIRMED") {
        throw new Error("Reservation not confirmed");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
      };
    }),

  // Verify manual code (web fallback)
  verifyCode: protectedProcedure
    .input(z.object({ verificationCode: z.string().length(6) }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(
            reservations.verificationCode,
            input.verificationCode.toUpperCase(),
          ),
        with: {
          listing: {
            columns: {
              sellerId: true,
            },
          },
          buyer: {
            columns: {
              email: true,
              phone: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid verification code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
      };
    }),

  // Complete pickup
  completePickup: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        signature: z.string().optional(), // Base64 image for mobile
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: {
            with: {
              seller: true,
            },
          },
          buyer: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can complete
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      const [updated] = await ctx.db
        .update(reservation)
        .set({
          status: "COMPLETED",
          completedAt: new Date(),
        })
        .where(eq(reservation.id, input.reservationId))
        .returning();

      // Send rating prompts to both parties
      await notifyPickupComplete({
        buyerEmail: existingReservation.buyer.email!,
        sellerEmail: existingReservation.listing.seller.email!,
        listingTitle: existingReservation.listing.title,
      }).catch((err) => console.error("Failed to send notification:", err));

      return updated;
    }),

  // Cancel expired reservations (for cron job)
  cancelExpiredReservations: protectedProcedure
    .mutation(async ({ ctx }) => {
      // Find all PENDING reservations that have expired
      const now = new Date();

      const expiredReservations = await ctx.db.query.reservation.findMany({
        where: (reservations, { and, eq, lt }) =>
          and(
            eq(reservations.status, "PENDING"),
            lt(reservations.expiresAt, now)
          ),
        with: {
          listing: true,
        },
      });

      if (expiredReservations.length === 0) {
        return {
          cancelled: 0,
          message: "No expired reservations found",
        };
      }

      // Cancel each expired reservation and return quantity to listing
      const results = await Promise.all(
        expiredReservations.map(async (res) => {
          try {
            await ctx.db.transaction(async (tx) => {
              // Update reservation status to CANCELLED
              await tx
                .update(reservation)
                .set({
                  status: "CANCELLED",
                  completedAt: new Date(),
                })
                .where(eq(reservation.id, res.id));

              // Return quantity to listing
              await tx
                .update(listing)
                .set({
                  quantityAvailable:
                    res.listing.quantityAvailable + res.quantityReserved,
                })
                .where(eq(listing.id, res.listingId));
            });
            return { id: res.id, success: true };
          } catch (error) {
            console.error(`Failed to cancel reservation ${res.id}:`, error);
            return { id: res.id, success: false };
          }
        })
      );

      const successCount = results.filter((r) => r.success).length;

      return {
        cancelled: successCount,
        failed: results.length - successCount,
        message: `Cancelled ${successCount} expired reservations`,
      };
    }),

  // Report no-show
  reportNoShow: protectedProcedure
    .input(z.object({ reservationId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can report
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Check if expired
      if (new Date() < existingReservation.expiresAt) {
        throw new Error("Reservation has not expired yet");
      }

      await ctx.db.transaction(async (tx) => {
        // Mark as no-show
        await tx
          .update(reservation)
          .set({ status: "NO_SHOW", completedAt: new Date() })
          .where(eq(reservation.id, input.reservationId));

        // Return quantity to listing
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable +
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));

        // Auto-assign 1-star rating from seller to buyer for no-show
        await tx.insert(rating).values({
          reservationId: input.reservationId,
          raterId: ctx.session.user.id, // seller
          ratedId: existingReservation.buyerId,
          score: 1,
          comment: "No-show - buyer did not pick up items within 48 hours",
        });
      });

      return { success: true };
    }),
});
