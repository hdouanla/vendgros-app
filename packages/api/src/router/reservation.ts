import { z } from "zod/v4";
import { and, desc, eq, inArray, sql } from "@acme/db";
import { randomBytes } from "crypto";
import { TRPCError } from "@trpc/server";

import { conversation, listing, rating, reservation, user } from "@acme/db/schema";

// Helper to calculate effective available quantity (minus pending reservations)
async function getEffectiveAvailableQuantity(
  db: any,
  listingId: string,
  quantityAvailable: number
): Promise<number> {
  const pendingReservations = await db
    .select({
      totalPending: sql<number>`COALESCE(SUM(${reservation.quantityReserved}), 0)::int`,
    })
    .from(reservation)
    .where(
      and(
        eq(reservation.listingId, listingId),
        eq(reservation.status, "PENDING")
      )
    );

  const pendingQuantity = pendingReservations[0]?.totalPending ?? 0;
  return Math.max(0, quantityAvailable - pendingQuantity);
}

import { notifyReservationCreated, notifyPickupComplete } from "../lib/notifications";
import { createTRPCRouter, protectedProcedure } from "../trpc";

// Helper to generate 6-digit alphanumeric code
function generateVerificationCode(): string {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

// Helper to generate QR hash
function generateQRHash(): string {
  return randomBytes(32).toString("hex");
}

export const reservationRouter = createTRPCRouter({
  // Create reservation with 5% deposit
  create: protectedProcedure
    .input(
      z.object({
        listingId: z.string(),
        quantity: z.number().int().positive(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const targetListing = await ctx.db.query.listing.findFirst({
        where: (listings, { eq }) => eq(listings.id, input.listingId),
      });

      if (!targetListing || targetListing.status !== "PUBLISHED" || !targetListing.isActive) {
        throw new Error("Listing not available");
      }

      // Prevent sellers from reserving their own listings
      if (targetListing.sellerId === ctx.session.user.id) {
        throw new Error("You cannot reserve your own listing");
      }

      // Check buyer's phone verification
      const buyer = await ctx.db.query.user.findFirst({
        where: (u, { eq }) => eq(u.id, ctx.session.user.id),
        columns: { phoneVerified: true },
      });

      if (!buyer?.phoneVerified) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Phone verification required to make reservations",
        });
      }

      // Calculate effective available (minus pending reservations)
      const effectiveAvailable = await getEffectiveAvailableQuantity(
        ctx.db,
        input.listingId,
        targetListing.quantityAvailable
      );

      if (input.quantity > effectiveAvailable) {
        throw new Error("Insufficient quantity available");
      }

      if (
        targetListing.maxPerBuyer &&
        input.quantity > targetListing.maxPerBuyer
      ) {
        throw new Error(`Maximum ${targetListing.maxPerBuyer} per buyer`);
      }

      const totalPrice = targetListing.pricePerPiece * input.quantity;
      const depositAmount = totalPrice * 0.05; // 5% deposit

      const qrCodeHash = generateQRHash();
      const verificationCode = generateVerificationCode();

      // Calculate expiry (48 hours from now)
      const expiresAt = new Date(Date.now() + 48 * 60 * 60 * 1000);

      const [newReservation] = await ctx.db
        .insert(reservation)
        .values({
          listingId: input.listingId,
          buyerId: ctx.session.user.id,
          quantityReserved: input.quantity,
          totalPrice,
          depositAmount,
          qrCodeHash,
          verificationCode,
          status: "PENDING",
          expiresAt,
          createdAt: new Date(), // Explicitly set to ensure correct timezone
          stripePaymentIntentId: null, // Will be set after Stripe integration
        })
        .returning();

      if (!newReservation) {
        throw new Error("Failed to create reservation");
      }

      // Send notification to buyer (fire-and-forget - don't await)
      notifyReservationCreated({
        buyerEmail: ctx.session.user.email!,
        buyerPhone: undefined,
        listingTitle: targetListing.title,
        depositAmount,
        verificationCode,
        expiresAt,
      }).catch((err) => console.error("Failed to send notification:", err));

      return {
        reservationId: newReservation.id,
        depositAmount,
        totalPrice,
        verificationCode,
        qrCodeHash,
        // Client secret will be generated by Stripe integration
      };
    }),

  // Confirm payment (update after Stripe payment)
  confirmPayment: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        stripePaymentIntentId: z.string(),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      if (existingReservation.buyerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Update reservation and decrement listing inventory
      await ctx.db.transaction(async (tx) => {
        // Update reservation status
        await tx
          .update(reservation)
          .set({
            status: "CONFIRMED",
            stripePaymentIntentId: input.stripePaymentIntentId,
          })
          .where(eq(reservation.id, input.reservationId));

        // Decrement listing inventory
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable -
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));

        // Create conversation for buyer-seller chat
        await tx
          .insert(conversation)
          .values({
            listingId: existingReservation.listingId,
            buyerId: existingReservation.buyerId,
            sellerId: existingReservation.listing.sellerId,
            reservationId: input.reservationId,
          })
          .onConflictDoNothing(); // In case conversation already exists
      });

      return { success: true };
    }),

  // Get reservation by ID
  getById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.id),
        with: {
          listing: {
            with: {
              seller: {
                columns: {
                  id: true,
                  name: true,
                  email: true,
                  phone: true,
                  verificationBadge: true,
                  ratingAverage: true,
                  ratingCount: true,
                  sellerRatingAverage: true,
                  sellerRatingCount: true,
                },
              },
            },
          },
          buyer: {
            columns: {
              id: true,
              name: true,
              email: true,
              phone: true,
              verificationBadge: true,
              ratingAverage: true,
              ratingCount: true,
              buyerRatingAverage: true,
              buyerRatingCount: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Reservation not found");
      }

      // Only buyer or seller can view
      if (
        result.buyerId !== ctx.session.user.id &&
        result.listing.sellerId !== ctx.session.user.id
      ) {
        throw new Error("Not authorized");
      }

      // Determine viewer role
      const isBuyer = result.buyerId === ctx.session.user.id;
      const isSeller = result.listing.sellerId === ctx.session.user.id;

      return {
        ...result,
        viewerRole: isBuyer && isSeller ? "both" : isBuyer ? "buyer" : "seller",
      };
    }),

  // Get my reservations (as buyer)
  myReservations: protectedProcedure.query(async ({ ctx }) => {
    const results = await ctx.db.query.reservation.findMany({
      where: (reservations, { eq }) => eq(reservations.buyerId, ctx.session.user.id),
      with: {
        listing: {
          with: {
            seller: {
              columns: {
                id: true,
                name: true,
                email: true,
              },
            },
          },
        },
      },
      orderBy: (reservations, { desc }) => [desc(reservations.createdAt)],
    });

    return results;
  }),

  // Get pending reservations awaiting payment (as buyer)
  getPendingPayments: protectedProcedure.query(async ({ ctx }) => {
    const results = await ctx.db.query.reservation.findMany({
      where: (reservations, { and, eq }) =>
        and(
          eq(reservations.buyerId, ctx.session.user.id),
          eq(reservations.status, "PENDING")
        ),
      with: {
        listing: {
          columns: {
            id: true,
            title: true,
            pricePerPiece: true,
          },
        },
      },
      // Sort by createdAt ascending - oldest first (closest to payment timeout)
      orderBy: (reservations, { asc }) => [asc(reservations.createdAt)],
    });

    return results;
  }),

  // Get reservations for a specific listing (for sellers to check if listing can be edited)
  getByListingId: protectedProcedure
    .input(z.object({ listingId: z.string() }))
    .query(async ({ ctx, input }) => {
      // First verify the user owns this listing
      const targetListing = await ctx.db.query.listing.findFirst({
        where: (listings, { eq }) => eq(listings.id, input.listingId),
      });

      if (!targetListing) {
        throw new Error("Listing not found");
      }

      if (targetListing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Get all reservations for this listing
      const results = await ctx.db.query.reservation.findMany({
        where: (reservations, { eq }) => eq(reservations.listingId, input.listingId),
        orderBy: (reservations, { desc }) => [desc(reservations.createdAt)],
      });

      return results;
    }),

  // Get pending pickups (as seller) - reservations that have been paid and are awaiting pickup
  getPendingPickups: protectedProcedure.query(async ({ ctx }) => {
    // Optimized: Use a single query with JOIN and WHERE on seller_id
    const results = await ctx.db
      .select({
        // Reservation fields
        id: reservation.id,
        listingId: reservation.listingId,
        buyerId: reservation.buyerId,
        quantityReserved: reservation.quantityReserved,
        totalPrice: reservation.totalPrice,
        depositAmount: reservation.depositAmount,
        qrCodeHash: reservation.qrCodeHash,
        verificationCode: reservation.verificationCode,
        status: reservation.status,
        stripePaymentIntentId: reservation.stripePaymentIntentId,
        expiresAt: reservation.expiresAt,
        completedAt: reservation.completedAt,
        createdAt: reservation.createdAt,
        updatedAt: reservation.updatedAt,
        // Listing fields (nested)
        listing: {
          id: listing.id,
          title: listing.title,
          pricePerPiece: listing.pricePerPiece,
          pickupAddress: listing.pickupAddress,
          postalCode: listing.postalCode,
          pickupInstructions: listing.pickupInstructions,
        },
        // Buyer fields (nested)
        buyer: {
          id: user.id,
          email: user.email,
          phone: user.phone,
          name: user.name,
        },
      })
      .from(reservation)
      .innerJoin(listing, eq(reservation.listingId, listing.id))
      .innerJoin(user, eq(reservation.buyerId, user.id))
      .where(
        and(
          eq(listing.sellerId, ctx.session.user.id),
          eq(reservation.status, "CONFIRMED")
        )
      )
      .orderBy(reservation.expiresAt);

    return results;
  }),

  // Get completed reservations for seller (delivered orders)
  getCompletedPickups: protectedProcedure.query(async ({ ctx }) => {
    const results = await ctx.db
      .select({
        // Reservation fields
        id: reservation.id,
        listingId: reservation.listingId,
        buyerId: reservation.buyerId,
        quantityReserved: reservation.quantityReserved,
        totalPrice: reservation.totalPrice,
        depositAmount: reservation.depositAmount,
        verificationCode: reservation.verificationCode,
        status: reservation.status,
        completedAt: reservation.completedAt,
        createdAt: reservation.createdAt,
        // Listing fields (nested)
        listing: {
          id: listing.id,
          title: listing.title,
          pricePerPiece: listing.pricePerPiece,
        },
        // Buyer fields (nested)
        buyer: {
          id: user.id,
          email: user.email,
          name: user.name,
        },
      })
      .from(reservation)
      .innerJoin(listing, eq(reservation.listingId, listing.id))
      .innerJoin(user, eq(reservation.buyerId, user.id))
      .where(
        and(
          eq(listing.sellerId, ctx.session.user.id),
          eq(reservation.status, "COMPLETED")
        )
      )
      .orderBy(desc(reservation.completedAt))
      .limit(50);

    return results;
  }),

  // Verify QR code (seller scans buyer's QR)
  verifyQR: protectedProcedure
    .input(z.object({ qrCodeHash: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(reservations.qrCodeHash, input.qrCodeHash),
        with: {
          listing: {
            columns: {
              sellerId: true,
            },
          },
          buyer: {
            columns: {
              id: true,
              email: true,
              phone: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid QR code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      if (result.status !== "CONFIRMED") {
        throw new Error("Reservation not confirmed");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
      };
    }),

  // Verify manual code (web fallback)
  verifyCode: protectedProcedure
    .input(z.object({ verificationCode: z.string().length(6) }))
    .mutation(async ({ ctx, input }) => {
      const result = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) =>
          eq(
            reservations.verificationCode,
            input.verificationCode.toUpperCase(),
          ),
        with: {
          listing: {
            columns: {
              id: true,
              sellerId: true,
              title: true,
              description: true,
              category: true,
              pricePerPiece: true,
              photos: true,
            },
          },
          buyer: {
            columns: {
              email: true,
              phone: true,
              name: true,
            },
          },
        },
      });

      if (!result) {
        throw new Error("Invalid verification code");
      }

      // Only seller can verify
      if (result.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      return {
        reservationId: result.id,
        buyerInfo: result.buyer,
        quantity: result.quantityReserved,
        balanceDue: result.totalPrice - result.depositAmount,
        totalPrice: result.totalPrice,
        depositPaid: result.depositAmount,
        pricePerPiece: result.listing.pricePerPiece,
        listing: {
          id: result.listing.id,
          title: result.listing.title,
          description: result.listing.description,
          category: result.listing.category,
          image: result.listing.photos?.[0] ?? null,
        },
      };
    }),

  // Complete pickup
  completePickup: protectedProcedure
    .input(
      z.object({
        reservationId: z.string(),
        signature: z.string().optional(), // Base64 image for mobile
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: {
            with: {
              seller: true,
            },
          },
          buyer: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can complete
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      const [updated] = await ctx.db
        .update(reservation)
        .set({
          status: "COMPLETED",
          completedAt: new Date(),
        })
        .where(eq(reservation.id, input.reservationId))
        .returning();

      // Send rating prompts to both parties
      await notifyPickupComplete({
        buyerEmail: existingReservation.buyer.email!,
        sellerEmail: existingReservation.listing.seller.email!,
        listingTitle: existingReservation.listing.title,
      }).catch((err) => console.error("Failed to send notification:", err));

      return updated;
    }),

  // Cancel expired reservations (for cron job)
  cancelExpiredReservations: protectedProcedure
    .mutation(async ({ ctx }) => {
      // Find all PENDING reservations that have expired
      const now = new Date();

      const expiredReservations = await ctx.db.query.reservation.findMany({
        where: (reservations, { and, eq, lt }) =>
          and(
            eq(reservations.status, "PENDING"),
            lt(reservations.expiresAt, now)
          ),
        with: {
          listing: true,
        },
      });

      if (expiredReservations.length === 0) {
        return {
          cancelled: 0,
          message: "No expired reservations found",
        };
      }

      // Cancel each expired reservation and return quantity to listing
      const results = await Promise.all(
        expiredReservations.map(async (res) => {
          try {
            await ctx.db.transaction(async (tx) => {
              // Update reservation status to CANCELLED
              await tx
                .update(reservation)
                .set({
                  status: "CANCELLED",
                  completedAt: new Date(),
                })
                .where(eq(reservation.id, res.id));

              // Return quantity to listing
              await tx
                .update(listing)
                .set({
                  quantityAvailable:
                    res.listing.quantityAvailable + res.quantityReserved,
                })
                .where(eq(listing.id, res.listingId));
            });
            return { id: res.id, success: true };
          } catch (error) {
            console.error(`Failed to cancel reservation ${res.id}:`, error);
            return { id: res.id, success: false };
          }
        })
      );

      const successCount = results.filter((r) => r.success).length;

      return {
        cancelled: successCount,
        failed: results.length - successCount,
        message: `Cancelled ${successCount} expired reservations`,
      };
    }),

  // Cancel pending reservation (buyer cancels before payment)
  cancel: protectedProcedure
    .input(z.object({ reservationId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
      });

      if (!existingReservation) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Reservation not found",
        });
      }

      // Only buyer can cancel their own reservation
      if (existingReservation.buyerId !== ctx.session.user.id) {
        throw new TRPCError({
          code: "FORBIDDEN",
          message: "Not authorized to cancel this reservation",
        });
      }

      // Can only cancel PENDING reservations (before payment)
      if (existingReservation.status !== "PENDING") {
        throw new TRPCError({
          code: "BAD_REQUEST",
          message: "Only pending reservations can be cancelled",
        });
      }

      // Delete the reservation
      await ctx.db
        .delete(reservation)
        .where(eq(reservation.id, input.reservationId));

      return { success: true };
    }),

  // Report no-show
  reportNoShow: protectedProcedure
    .input(z.object({ reservationId: z.string() }))
    .mutation(async ({ ctx, input }) => {
      const existingReservation = await ctx.db.query.reservation.findFirst({
        where: (reservations, { eq }) => eq(reservations.id, input.reservationId),
        with: {
          listing: true,
        },
      });

      if (!existingReservation) {
        throw new Error("Reservation not found");
      }

      // Only seller can report
      if (existingReservation.listing.sellerId !== ctx.session.user.id) {
        throw new Error("Not authorized");
      }

      // Check if expired
      if (new Date() < existingReservation.expiresAt) {
        throw new Error("Reservation has not expired yet");
      }

      await ctx.db.transaction(async (tx) => {
        // Mark as no-show
        await tx
          .update(reservation)
          .set({ status: "NO_SHOW", completedAt: new Date() })
          .where(eq(reservation.id, input.reservationId));

        // Return quantity to listing
        await tx
          .update(listing)
          .set({
            quantityAvailable:
              existingReservation.listing.quantityAvailable +
              existingReservation.quantityReserved,
          })
          .where(eq(listing.id, existingReservation.listingId));

        // Auto-assign 1-star rating from seller to buyer for no-show
        await tx.insert(rating).values({
          reservationId: input.reservationId,
          raterId: ctx.session.user.id, // seller
          ratedId: existingReservation.buyerId,
          ratingType: "AS_BUYER", // Rating the buyer's behavior
          score: 1,
          comment: "No-show - buyer did not pick up items within 48 hours",
        });
      });

      return { success: true };
    }),
});
